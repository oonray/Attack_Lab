kind: ConfigMap
metadata:
  name: opnevpn-script
apiVersion: v1
data:
  route-override.sh: |-
     #!/bin/sh
     VPN_GATEWAY=$(route -n | awk 'NR==3' | awk '{ print $2 }')
     ip route del 0.0.0.0/1 via $VPN_GATEWAY
     echo "Route Updated"

---
kind: ConfigMap
metadata:
  name: kali-insall-script
apiVersion: v1
data:
  install.sh: |-
     #!/bin/sh
     while true; do sleep 5; done

---
kind: ConfigMap
metadata:
  name: tmux
apiVersion: v1
data:
   .tmux.conf: |-
    set -g default-terminal "screen-256color"
    set -g mouse on

---
kind: ConfigMap
metadata:
  name: sockd-conf
apiVersion: v1
data:
  sockd.conf: |-
    # Logging
    logoutput: /var/log/sockd.log
    errorlog: stderr

    # Server address specification
    internal: eth0 port = 1080
    external: tun0

    # Authentication methods
    clientmethod: none
    socksmethod: none

    # Server identities
    user.unprivileged: sockd

    ##
    ## SOCKS client access rules
    ##
    # Rule processing stops at the first match; no match results in blocking

    # Block access to socks server from 192.0.2.22
    # client block {
    #       # Block connections from 192.0.2.22/32
    #       from: 192.0.2.22/24 to: 0.0.0.0/0
    #       log: error # connect disconnect
    # }

    # Allow all connections
    client pass {
        from: 0.0.0.0/0 to: 0.0.0.0/0
        log: error connect disconnect
    }

    ##
    ## SOCKS command rules
    ##
    # Rule processing stops at the first match; no match results in blocking

    # Block communication with www.example.org
    # socks block {
    #        from: 0.0.0.0/0 to: www.example.org
    #        command: bind connect udpassociate
    #        log: error # connect disconnect iooperation
    # }

    # Generic pass statement - bind/outgoing traffic
    socks pass {
        from: 0.0.0.0/0 to: 0.0.0.0/0
        command: bind connect udpassociate
        log: error connect disconnect # iooperation
    }

    # Block incoming connections/packets from ftp.example.org
    # socks block {
    #        from: ftp.example.org to: 0.0.0.0/0
    #        command: bindreply udpreply
    #        log: error # connect disconnect iooperation
    # }

    # Generic pass statement for incoming connections/packets
    socks pass {
        from: 0.0.0.0/0 to: 0.0.0.0/0
        command: bindreply udpreply
        log: error connect disconnect # iooperation
    }

---
kind: ConfigMap
metadata:
  name: goproxy
apiVersion: v1
data:
  proxy.go: |-
    package main

    import (
      "os"
      "net/http"
      "net/http/httputil"
      "net/url"
      "github.com/gorilla/mux"
      log "github.com/sirupsen/logrus"
      "github.com/gorilla/handlers"
    )

    var (
      hostProxy 	= make(map[string]string)
      proxies		= make(map[string]*httputil.ReverseProxy)
    )

    func init(){
      hostProxy["127.0.0.1"] = "http://kalamari:ihateseafood@10.10.10.21:3128/"
      hostProxy["10.10.10.21"] = "http://kalamari:ihateseafood@10.10.10.21:3128/"
      hostProxy["joker.htb"] = "http://kalamari:ihateseafood@joker.htb:3128/"

      for k,v := range hostProxy {
        remote, err := url.Parse(v)
        if (err!=nil){
          log.Fatalf("Unable To Parse Proxy Target")
        }
        proxies[k] = httputil.NewSingleHostReverseProxy(remote)
      }
    }

    func main() {
      r := mux.NewRouter()
      for host, proxy := range proxies {
        r.Host(host).Handler(proxy)
      }
      logged := handlers.LoggingHandler(os.Stdout, r)
      log.Fatal(http.ListenAndServe(":8081",logged))
    }

---
kind: ConfigMap
metadata:
  name: goforward
apiVersion: v1
data:
  forward.go: |-
    package main

    import (
      "net"
      "bufio"
      "io"
      log "github.com/sirupsen/logrus"
    )

    //const port int = 8081
    //const con_port int = 3128

    var (
      in net.Listener
      out net.Conn
      reader io.Reader
      writer io.Writer
    )

    func main() {
      var err error

      log.Info("Connecting to 10.10.10.21:3128")
      out, err = net.Dial("tcp","10.10.10.21:3128")
      if err != nil {
        log.Infof("Could not connect: %s",err)
        return
      }

      log.Info("Listening :8081")
      in, err = net.Listen("tcp",":8081")
      if err != nil {
        log.Infof("Could not listen: %s",err)
        return
      }

      writer := bufio.NewWriter(out)

      for {
        con, err := in.Accept()
        if err != nil {continue}
        log.Info("Got connection")

        reader := bufio.NewReader(con)
        io.Copy(writer,reader)
      }
    }
