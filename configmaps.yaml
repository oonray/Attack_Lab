kind: ConfigMap
metadata:
  name: opnevpn-script
apiVersion: v1
data:
  route-override.sh: |-
     #!/bin/sh
     VPN_GATEWAY=$(route -n | awk 'NR==3' | awk '{ print $2 }')
     ip route del 0.0.0.0/1 via $VPN_GATEWAY
     echo "Route Updated"

---
kind: ConfigMap
metadata:
  name: kali-insall-script
apiVersion: v1
data:
  install.sh: |-
     #!/bin/sh
     while true; do sleep 5; done

---
kind: ConfigMap
metadata:
  name: tmux
apiVersion: v1
data:
   .tmux.conf: |-
    set -g default-terminal "screen-256color"
    set -g mouse on

---
kind: ConfigMap
metadata:
  name: sockd-conf
apiVersion: v1
data:
  sockd.conf: |-
    # Logging
    logoutput: /var/log/sockd.log
    errorlog: stderr

    # Server address specification
    internal: eth0 port = 1080
    external: tun0

    # Authentication methods
    clientmethod: none
    socksmethod: none

    # Server identities
    user.unprivileged: sockd

    ##
    ## SOCKS client access rules
    ##
    # Rule processing stops at the first match; no match results in blocking

    # Block access to socks server from 192.0.2.22
    # client block {
    #       # Block connections from 192.0.2.22/32
    #       from: 192.0.2.22/24 to: 0.0.0.0/0
    #       log: error # connect disconnect
    # }

    # Allow all connections
    client pass {
        from: 0.0.0.0/0 to: 0.0.0.0/0
        log: error connect disconnect
    }

    ##
    ## SOCKS command rules
    ##
    # Rule processing stops at the first match; no match results in blocking

    # Block communication with www.example.org
    # socks block {
    #        from: 0.0.0.0/0 to: www.example.org
    #        command: bind connect udpassociate
    #        log: error # connect disconnect iooperation
    # }

    # Generic pass statement - bind/outgoing traffic
    socks pass {
        from: 0.0.0.0/0 to: 0.0.0.0/0
        command: bind connect udpassociate
        log: error connect disconnect # iooperation
    }

    # Block incoming connections/packets from ftp.example.org
    # socks block {
    #        from: ftp.example.org to: 0.0.0.0/0
    #        command: bindreply udpreply
    #        log: error # connect disconnect iooperation
    # }

    # Generic pass statement for incoming connections/packets
    socks pass {
        from: 0.0.0.0/0 to: 0.0.0.0/0
        command: bindreply udpreply
        log: error connect disconnect # iooperation
    }

    #route {
    #  from: 0.0.0.0/0 to: 10.10.10.21/32 via: 10.10.10.21 port=3128
    #  proxyprotocol: http_v1.0
    #  }
---
kind: ConfigMap
metadata:
  name: goproxy
apiVersion: v1
data:
  proxy.go: |-
    package main

    import (
      "flag"
      "net/http"
      "net/http/httputil"
      "net/url"
      "github.com/gorilla/mux"
      log "github.com/Sirupsen/logrus"
    )

    var (
      hostProxy 	= make(map[string]string)
      proxies		= make(map[string]*httputil.ReverseProxy)
    )

    func init(){
      hostProxy["10.10.10.21"] = "http://kalamari:ihateseafood@10.10.10.21:3128/"
      hostProxy["joker.htb"] = "http://kalamari:ihateseafood@joker.htb:3128/"

      for k,v := range hostProxy {
        remote, err := url.Parse(v)
        if (err!=nil){
          log.Fatalf("Unable To Parse Proxy Target")
        }
        proxies[k] = httputil.NewSingleHostReverseProxy(remote)
      }
    }

    func main() {
      r = mux.NewRouter()
      for host, proxy := range proxies {
        r.Host(host).Handler(proxy)
      }
      log.Fatal(http.ListenAndServe(":8081",r))
    }
